#!/bin/bash

# Default runtime settings
CONCURRENCY=[cpus]*10
CSV=0
CSV_ADD_DOMAIN=0
CSV_NO_HEADER=0
DEFAULT_TTL=1h
DOMAIN=
DOMAIN_LIMIT=1000000
DICTIONARY=www
DICTIONARY_LIMIT=1000000
NAME_SERVERS=SOA
NS_PER_QUERY=3
MAX_NS_CONS=1
NO_WILDCARD_CHECK=
OUTPUT=stdout
PATH_TO_DIG=dig
RR_TYPES=SOA,NS,MX,TXT,A,AAAA,BR_A
SKIP_CNAME_RECURSION=0
SKIP_TTL=0
TCP=0
VERBOSE=0
WAIT=2


# Extract user arguments
while test $# -gt 0; do
  case "$1" in
    -h|--help)
      echo " "
      echo " 'braxfr' attempts to simulate a zone transfer for DOMAIN without use of AXFR."
      echo " It uses dig and a brute force dictionary to discover resource records and "
      echo " construct a zone file. Although accuracy is not 100% guaranteed, braxfr will"
      echo " generally discover a significant number of resource records associated with"
      echo " DOMAIN. braxfr performance is dependent on network capacity where it is run,"
      echo " concurrency, and resolve response time. An attempt will be made to discover and"
      echo " exclude wildcard records (listed as a single record * IN A...)"
      echo " "
      echo " Each DOMAIN value may be either a domain, or the path to a file containing a"
      echo " list of domains (one per line)"
      echo " "
      echo " braxfr [options] DOMAIN1 DOMAIN2 DOMAIN3 ... DOMAINN"
      echo " "
      echo " options:"
      echo "  -c, --concurrency=CONCURRENCY Max DNS query concurrency. May be an mathmatical"
      echo "                                expression containing the token [cpus]. For"
      echo "                                example --concurrency='[cpus]*10' in an 8 core"
      echo "                                environment translates to 8*10=80 or"
      echo "                                --concurrency=80. Actual concurrency will not"
      echo "                                exceed the # of words in DICTIONARY or the "
      echo "                                optional DICTIONARY_LIMIT value. Additionally,"
      echo "                                actual concurrency will not exceed the number of"
      echo "                                NAME_SERVERS specified * MAX_NS_CONS. Default"
      echo "                                CONCURRENCY is '[cpus]*10'"      
      echo "                                "
      echo "  --csv                         Record results in CSV instead of DNS Zone file"
      echo "                                format. CSV files have the following columns:"
      echo "                                Name, TTL, Record Type, Record Data"
      echo "                                and the first row is a header"
      echo "                                "
      echo "  --csv-add-domain              If set in conjunction with --csv, then Domain"
      echo "                                will be added as the first column in the CSV"
      echo "                                output"
      echo "                                "
      echo "  --csv-no-header               Don't include a header row in CSV output"
      echo "                                "
      echo "  --default-ttl                 Default domain TTL to use when --skip-ttl is"
      echo "                                set. Default is 1h"
      echo "                                "
      echo "  -d, --dictionary=DICTIONARY   Brute force dictionary - a list of words to"
      echo "                                query to 'discover' zone resource records. This"
      echo "                                argument may either be a comma separate list of"
      echo "                                words or the path to a file containing words"
      echo "                                (line separated). This repository includes a"
      echo "                                dnspop submodule with some pre-made brute force"
      echo "                                dictionaries based on Rapid7's Project Sonar"
      echo "                                Forward DNS data set. These dictionaries can be"
      echo "                                referenced using the DICTIONARY values dnspop-1k,"
      echo "                                dnspop-10k, dnspop-100k and dnspop-1m. See"
      echo "                                https://github.com/bitquark/dnspop for more"
      echo "                                information. Default DICTIONARY value is just"
      echo "                                'www'"
      echo "                                "
      echo "  --dig=PATH_TO_DIG             Path to dig utility if not in PATH"
      echo "                                "
      echo "  -h, --help                    show braxfr help"
      echo "                                "
      echo "  -l, --limit=DICTIONARY_LIMIT  Max # of entries in DICTIONARY to query. For"
      echo "                                example, if DICTIONARY references a file with"
      echo "                                1 million words and DICTIONARY_LIMIT is 5000,"
      echo "                                then only the first 5000 words will be checked."
      echo "                                The default limit is 1 million words"
      echo "                                "
      echo "  --domain-limit=DOMAIN_LIMIT   Max # of DOMAINS to query The default limit is"
      echo "                                1 million words"
      echo "                                "
      echo "  -n, --ns=NAME_SERVERS         Explicit name servers to use for DNS queries."
      echo "                                Multiple name servers may be specified each"
      echo "                                separated by a comma. Additionally, this"
      echo "                                argument may reference a file containing a list"
      echo "                                (line separated) of name servers to use. The"
      echo "                                value 'SOA' will be translated to all"
      echo "                                authoritative name servers assigned to DOMAIN."
      echo "                                The value 'LOCAL' will be translated to all"
      echo "                                resolvers listed in /etc/resolv.conf. Default "
      echo "                                NAME_SERVERS is SOA"
      echo "                                "
      echo "  --no-wildcard                 Don't check for wildcard records. Default is to"
      echo "                                check for wildcards if the dictionary is >100"
      echo "                                words"
      echo "                                "
      echo "  --ns-per-query=NS_PER_QUERY   Number of name servers to attempt per query. At"
      echo "                                least 1 server must respond before WAIT. Default"
      echo "                                is 3. If the number of name servers specified is"
      echo "                                less than this value, then every name server"
      echo "                                may be attempted for each query"
      echo "                                "
      echo "  -o, --output=OUTPUT           Path to a file where the resulting zone file/csv"
      echo "                                should be written. If not specified, results"
      echo "                                will be written to stdout. If multiple DOMAINS"
      echo "                                specified, this argument may contain the string"
      echo "                                [domain] which will be replaced with the domain"
      echo "                                value. e.g. --output=[domain]-zonfile with"
      echo "                                DOMAIN=yahoo.com would result in an output file"
      echo "                                named 'yahoo.com-zonefile"
      echo "                                "
      echo "  -s, --skip-cname-recursion    Exclude recursive CNAME records"
      echo "                                "
      echo "  --skip-ttl                    Skip SOA query for global TTL - which is a"
      echo "                                blocking operation that can thus slow down the"
      echo "                                process. If CSV is set, TTL is automatically"
      echo "                                skipped"
      echo "                                "
      echo "  -t, --tcp                     Invoke TCP/IP DNS queries only (i.e. 'dig +tcp')"
      echo "                                "
      echo "  -v, --verbose                 Show verbose output to stderr"
      echo "                                "
      echo "  -w, --wait=WAIT               Timeout for DNS queries in seconds - default 2"
      echo "                                Name servers that time out consecutively will be"
      echo "                                blacklisted from additional queries"
      echo "                                "
      echo "  -x, --max-ns-cons=MAX_NS_CONS Max concurrent queries for each NAME_SERVER. For"
      echo "                                example, if MAX_NS_CONS=2, DICTIONARY contains"
      echo "                                4k words, NAME_SERVERS defined 1k servers, and"
      echo "                                CONCURRENCY>=2000, then brute force queries"
      echo "                                would be completed in 2 iterations, each for 2k"
      echo "                                words. Default MAX_NS_CONS is 1. NOTE: this arg"
      echo "                                is ignored for non brute-force records which are"
      echo "                                queried in a single concurrent batch using all"
      echo "                                available name servers"
      echo "                                "
      echo "  -y, --rr-types=RR_TYPES       Type of DNS resource records to include in"
      echo "                                resource discovery. For a full list of DNS"
      echo "                                record types, see"
      echo "                                https://en.wikipedia.org/wiki/List_of_DNS_record_types"
      echo "                                Record types prefixed with 'BR_' will be included"
      echo "                                in brute force queries. Multiple record types"
      echo "                                may be specified, each separated by a comma."
      echo "                                Additionally, this argument may reference a file"
      echo "                                containing a line separated list of record types."
      echo "                                The default RR_TYPES value is as follows:"
      echo "                                SOA,NS,MX,TXT,A,AAAA,BR_A"
      echo "                                NOTE: BR_A will capture both A and CNAME records"
      echo "                                including full CNAME recursion - thus it is"
      echo "                                redundant to specify both"
      echo "                                "
      echo " "
      exit 0
      ;;
    -c)
      shift
      CONCURRENCY=$1
      shift
      ;;
    --concurrency*)
      CONCURRENCY=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    --csv)
      shift
      CSV=1
      ;;
    --csv-add-domain)
      shift
      CSV_ADD_DOMAIN=1
      ;;
    --csv-no-header)
      shift
      CSV_NO_HEADER=1
      ;;
    --default-ttl*)
      DEFAULT_TTL=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -d)
      shift
      DICTIONARY=$1
      shift
      ;;
    --dictionary*)
      DICTIONARY=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    --dig*)
      PATH_TO_DIG=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -l)
      shift
      DICTIONARY_LIMIT=$1
      shift
      ;;
    --limit*)
      DICTIONARY_LIMIT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    --domain-limit*)
      DOMAIN_LIMIT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -n)
      shift
      NAME_SERVERS=$1
      shift
      ;;
    --no-wildcard)
      shift
      NO_WILDCARD_CHECK=1
      ;;
    --ns-per-query)
      NS_PER_QUERY=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    --ns*)
      NAME_SERVERS=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -o)
      shift
      OUTPUT=$1
      shift
      ;;
    --output*)
      OUTPUT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -s|--skip-cname-recursion)
      shift
      SKIP_CNAME_RECURSION=1
      ;;
    --skip-ttl)
      shift
      SKIP_TTL=1
      ;;
    -t|--tcp)
      shift
      TCP=1
      ;;
    -v|--verbose)
      shift
      VERBOSE=1
      ;;
    -w)
      shift
      WAIT=$1
      shift
      ;;
    --wait*)
      WAIT=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -x)
      shift
      MAX_NS_CONS=$1
      shift
      ;;
    --max-ns-cons*)
      MAX_NS_CONS=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    -y)
      shift
      RR_TYPES=$1
      shift
      ;;
    --rr-types*)
      RR_TYPES=`echo $1 | sed -e 's/^[^=]*=//g'`
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Populate domains array
DOMAINS=()
while true; do
  if ! [ -z $1 ] && [ "$1" != "" ]; then
    if ! [ -f "$1" ] && ! [[ "$1" =~ ^.*\..*$ ]]; then
      >&2 echo "Invalid domain $1"
      exit 1
    else
      DOMAINS+=($1)
      shift
    fi
  else
    break
  fi
done

# Internal variables

# Script directory
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Timeout command
TIMEOUT=
which timeout &>/dev/null
if [ $? -eq 0 ]; then
  TIMEOUT="timeout $WAIT"
else
  which gtimeout &>/dev/null
  if [ $? -eq 0 ]; then
    TIMEOUT="gtimeout $WAIT"
  fi
fi

# Name server pointer and count
ns_ptr=0
ns_count=0

# Converts a concurrency string to a numeric value by substituting [cpus] with
# the corresponding # of CPUs present in the environment and evaluating any 
# mathmatical expressions
function get_concurrency() {
  concurrency=
  if ! [ -z $1 ]; then
    concurrency=$((${1/\[cpus\]/$(getconf _NPROCESSORS_ONLN)}))
  fi
  echo $concurrency
}

# Generates a temporary dictionary file if $DICTIONARY is a comma separated
# list of words - otherwise returns the value of $DICTIONARY
function get_dictionary() {
  dictionary=
  if ! [ -z $1 ]; then
    dictionary=$1
    # Generate temporary dictionary file from csv command line args
    if ! [ -f $dictionary ] && ! [[ $dictionary =~ ^.*/.*$ ]]; then
      if [ $dictionary = "dnspop-1k" ] || [ $dictionary = "dnspop-10k" ] || [ $dictionary = "dnspop-100k" ] || [ $dictionary = "dnspop-1m" ]; then
        filter=$DIR/dnspop/results/bitquark_*_subdomains_popular_1000
        if [ $dictionary = "dnspop-10k" ]; then
          filter="${filter}0"
        elif [ $dictionary = "dnspop-100k" ]; then
          filter="${filter}00"
        elif [ $dictionary = "dnspop-1m" ]; then
          filter="${filter}000"
        fi
        dfile=`ls $filter`
        if [ $? -eq 0 ]; then
          dictionary=$dfile
        else
          >&2 echo "Unable to locate DNSpop dictionary $dictionary using $filter - is DNSpop present?"
          exit 1
        fi
      else
        dfile=/tmp/braxfr_$RANDOM
        for word in ${dictionary//,/ }; do
          echo $word >>$dfile
        done
        dictionary=$dfile
      fi
    fi
  fi
  echo $dictionary
}

# Writes a line to the output destination. This function uses the following
# arguments
# $1) Line to output
# $2) If 1, will not be printed if CSV==1
# $3) If 1, then subdomain will be replaced with wildcard
function print_to_output() {
  local is_cname=
  local line=
  while IFS= read -r line ; do
    if ! [ -z "$line" ] && [ $CSV -eq 1 ]; then
      if [[ $line =~ ^([^[:blank:]]*)[[:blank:]]*([0-9]*)[[:blank:]]+[inIN]{2}[[:blank:]]+([^[:blank:]]+)[[:blank:]]*(.*)$ ]]; then
        if [ $CSV_ADD_DOMAIN -eq 1 ]; then
          line="$DOMAIN,"
        else
          line=""
        fi
        line="${line}${BASH_REMATCH[1]},${BASH_REMATCH[2]},${BASH_REMATCH[3]},${BASH_REMATCH[4]}"
      else
        >&2 echo "Unable to parse line for CSV output: $line"
        line=
      fi
    fi
    if [ "$line" != "" ] && [ "${line:0:1}" != ';' ]; then
      if [ $SKIP_CNAME_RECURSION -eq 1 ] && [ -z $is_cname ]; then
        if [[ $line =~ " CNAME " ]] || [[ $line =~ " cname " ]]; then
          is_cname=1
        else
          is_cname=0
        fi
      elif [ $SKIP_CNAME_RECURSION -eq 1 ] && [ $is_cname -eq 1 ]; then
        break
      fi
      # Wildcard records
      if ! [ -z $3 ] && [ $3 -eq 1 ] && [[ "$line" =~ ^braxfr[0-9]+\.(.*)$ ]]; then
        line="*.${BASH_REMATCH[1]}"
      elif [ "$wildcard_a" != "" ] && [[ "$line" == "*$wildcard_a" ]]; then
        print_verbose "Skipping A wildcard record $line"
        continue
      elif [ "$wildcard_aaaa" != "" ] && [[ "$line" == "*$wildcard_aaaa" ]]; then
        print_verbose "Skipping AAAA wildcard record $line"
        continue
      fi
      if [ $CSV -eq 0 ] || [ -z $2 ] || [ $2 -eq 0 ]; then
        if [ $OUTPUT = "stdout" ]; then
          echo $line
        else
          echo $line >>$OUTPUT
        fi
      fi
    fi
  done <<< "$1"
}

# Prints verbose output if applicable. This function uses the following arguments:
# $1) Message
function print_verbose() {
  if [ $VERBOSE -eq 1 ]; then
    >&2 echo $1
  fi
}

# Executes dig based on the following arguments
# $1) target
# $2) type
# $3) set to 1 for +short (otherwise +noall +answer will be assumed)
# $4) set to 1 to only use non SOA name servers
# Returns the dig output. Exit with status code 1 on error
function dig_cmd() {
  if [ $ns_ptr -ge $ns_count ]; then
    ns_ptr=0
  fi
  
  local ns=
  for i in `seq 1 $NS_PER_QUERY`; do
    local ptr=$(( $ns_ptr + $i - 1 ))
    if [ $ptr -ge $ns_count ]; then
      ptr=$(( $i - 1 ))
      if [ $ptr -ge $ns_count ]; then
        ptr=0
      fi
    fi
    if [ -z $4 ] || [ $4 -eq 0 ] && [ "${domain_name_servers[$ptr]}" != "" ]; then
      ns="$ns @${domain_name_servers[$ptr]}"
    elif [ "${name_servers[$ptr]}" != "" ]; then
      ns="$ns @${name_servers[$ptr]}"
    fi
  done
  if [ -z $3 ] || [ $3 -eq 0 ]; then
    opts='+noall +answer'
  else
    opts='+short'
  fi
  if [ $TCP -eq 1 ]; then
    opts="$opts +tcp"
  fi
  opts="$opts +time=$WAIT"
  
  local cmd="$TIMEOUT $PATH_TO_DIG $ns $opts $1 $2"
  if [ $VERBOSE -eq 1 ]; then print_verbose "> $cmd"; fi
  $cmd 2>/dev/null | while read line; do
    if [ "$line" != "" ] && [ "${line:0:1}" != ";" ]; then
      echo $line
    fi
  done
}


# Validate runtime parameters

# domain
if [ ${#DOMAINS[@]} -eq 0 ]; then
  >&2 echo "At least 1 domain is required"
  exit 1
fi

# dig
$PATH_TO_DIG &>/dev/null
if [ $? -ne 0 ]; then
  if [ "$PATH_TO_DIG" = "dig" ]; then
    >&2 echo "dig not found in PATH"
  else
    >&2 echo "Invalid dig path --dig=$PATH_TO_DIG"
  fi
  exit 1
fi

# concurrency
concurrency=$(get_concurrency $CONCURRENCY)
if [ -z $concurrency ] || [ $concurrency -eq 0 ]; then
  >&2 echo "Unable to determine concurrency from --concurrency=$CONCURRENCY"
  exit 1
fi

# dictionary
dictionary=$(get_dictionary $DICTIONARY)
if [ -z $dictionary ] || ! [ -f $dictionary ]; then
  >&2 echo "Invalid dictionary --dictionary=$DICTIONARY"
  exit 1
fi

# dictionary limit
dictionary_limit=$(($DICTIONARY_LIMIT * 1))
if [ $dictionary_limit -le 0 ]; then
  >&2 echo "DICTIONARY_LIMIT must be at least 1"
  exit 1
fi

if [ -z $NO_WILDCARD_CHECK ]; then
  if [ $(cat $dictionary | wc -l) -lt 100 ] || [ $dictionary_limit -lt 100 ]; then
    NO_WILDCARD_CHECK=1
  else
    NO_WILDCARD_CHECK=0
  fi
fi

# NS_PER_QUERY
ns_per_query=$(($NS_PER_QUERY * 1))
if [ $ns_per_query -le 0 ]; then
  >&2 echo "--ns-per-query=$NS_PER_QUERY is invalid"
  exit 1
fi

# name servers
name_servers=()
add_soa_ns=0
for ns in ${NAME_SERVERS//,/ }; do
  ns_lower=$(echo "$ns" | awk '{print tolower($0)}')
  if [ "$ns_lower" = "local" ]; then
    while read ns; do
      if [[ "${ns:11}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        name_servers+=(${ns:11})
      fi
    done </etc/resolv.conf
  elif [ "$ns_lower" = "soa" ]; then
    add_soa_ns=1
  elif [ -f "$ns" ]; then
    name_servers+=(`cat $ns`)
  else
    if [ -z $ns ]; then
      >&2 echo "Invalid name server $ns"
    else
      name_servers+=($ns)
    fi
  fi
done
ns_count=${#name_servers[@]}
if [ $ns_count -eq 0 ] && [ $add_soa_ns -eq 0 ]; then
  >&2 echo "Unable to determine name servers from --ns=$NAME_SERVERS"
  exit 1
else
  for ((i = 0; i < $ns_count; ++i)); do
    ns=${name_servers[$i]}
    if ! [[ "$ns" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      if [ "${ns: -1}" = "." ]; then
        ns=${ns%?}
      fi
      ip=$(dig_cmd $ns A 1 1)
      ns_ptr=$(( $ns_ptr + 1 ))
      if [ "$ip" != "" ]; then
        unset $name_servers[$i]
        >&2 echo "Unable to determine IP address for name server $ns"
      else
        name_servers[$i]=$ip
      fi
    fi
  done
fi

# Resource record types
rr_types=()
rr_br_types=()
for type in ${RR_TYPES//,/ }; do
  type_lower=$(echo "$type" | awk '{print tolower($0)}')
  if [ ${type_lower::3} = "br_" ]; then
    rr_br_types+=(${type:3})
  else
    rr_types+=($type)
  fi
done
valid_rr_types=(a aaaa afsdb apl caa cdnskey cds cert cname dhcid dlv dnskey ds ipseckey key kx loc mx naptr ns nsec nsec3 nsec3param ptr rrsig rp sig soa srv sshfp ta tkey tlsa tsig txt uri dname)
validate_types=("${rr_br_types[@]}" "${rr_types[@]}")
for type in ${validate_types[@]}; do
  type_lower=$(echo "$type" | awk '{print tolower($0)}')
  if [[ ! " ${valid_rr_types[@]} " =~ " ${type_lower} " ]]; then
    >&2 echo "Resource record type $type is invalid"
    exit 1
  fi
done

# Wait
wait=$(($WAIT * 1))
if [ $wait -eq 0 ]; then
  >&2 echo "--wait=$WAIT is invalid"
  exit 1
fi

# Max name server connections
max_ns_cons=$(($MAX_NS_CONS * 1))
if [ $max_ns_cons -eq 0 ]; then
  >&2 echo "--max-ns-cons=$MAX_NS_CONS is invalid"
  exit 1
fi

# Arguments valid
if [ $VERBOSE -eq 1 ]; then
  print_verbose "arguments validated - running braxfr using arguments:"
  print_verbose "CONCURRENCY=$concurrency"
  print_verbose "CSV=$CSV"
  print_verbose "CSV_ADD_DOMAIN=$CSV_ADD_DOMAIN"
  print_verbose "DICTIONARY=$dictionary"
  print_verbose "DICTIONARY_LIMIT=$DICTIONARY_LIMIT"
  print_verbose "MAX_NS_CONS=$MAX_NS_CONS"
  print_verbose "OUTPUT=$OUTPUT"
  print_verbose "PATH_TO_DIG=$PATH_TO_DIG"
  print_verbose "TCP=$TCP"
  print_verbose "VERBOSE=$VERBOSE"
  print_verbose "WAIT=$WAIT"
  >&2 echo "DOMAINS=${DOMAINS[@]}"
  >&2 echo "NAME_SERVERS=${name_servers[@]}"
  >&2 echo "RR_TYPES=${rr_types[@]}"
  >&2 echo "BR_RR_TYPES=${rr_br_types[@]}"
fi


BASE_OUTPUT="$OUTPUT"
FIRST_DOMAIN=1
domain_file="/tmp/braxfr_$RANDOM"
subprocs=0
domain_counter=0
for DOMAIN in ${DOMAINS[@]}; do
  if [ $domain_counter -gt $DOMAIN_LIMIT ]; then
    print_verbose "--domain-limit $DOMAIN_LIMIT reach - exiting"
    break
  fi
  if ! [ -f $DOMAIN ]; then
    echo "$DOMAIN" >$domain_file
    DOMAIN=$domain_file
  fi
  
  while read DOMAIN; do
    domain_counter=$(( $domain_counter + 1 ))
    if [ $domain_counter -gt $DOMAIN_LIMIT ]; then
      break
    fi
    domain_name_servers=("${name_servers[@]}")
    
    if [ $CSV -eq 0 ] && [ $SKIP_TTL -eq 0 ]; then
      SOA=$(dig_cmd $DOMAIN SOA)
      ns_ptr=$(( $ns_ptr + 1 ))
      if [ "$SOA" = "" ]; then
        >&2 echo "Unable to determine SOA for $DOMAIN"
        continue
      fi
    else
      SOA=
    fi
  
    # SOA name servers
    if [ $add_soa_ns -eq 1 ]; then
      ns_query=$(dig_cmd $DOMAIN NS 1)
      ns_ptr=$(( $ns_ptr + 1 ))
      if [ "$ns_query" = "" ]; then
        >&2 echo "Unable to determine name servers [NS] for $DOMAIN"
        continue
      fi
      for record in $ns_query; do
        if [ "$record" = "" ] || [ "${record:0:1}" = ";" ]; then
          continue
        fi
      
        if ! [[ "$record" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          if [ "${record: -1}" = "." ]; then
            record=${record%?}
          fi
          ip=$(dig_cmd $record A 1 1)
          ns_ptr=$(( $ns_ptr + 1 ))
          if [ "$ip" = "" ]; then
            >&2 echo "Unable to determine IP address for name server $record"
          else
            domain_name_servers+=($ip)
          fi
        else
          domain_name_servers+=($record)
        fi
      done
    fi
    ns_count=${#domain_name_servers[@]}
    if [ $ns_count -eq 0 ]; then
      >&2 echo "Unable to determine name servers for $DOMAIN"
      continue
    fi
  
    # dynamic output file
    OUTPUT=$BASE_OUTPUT
    if [ $OUTPUT != 'stdout' ]; then
      OUTPUT=${BASE_OUTPUT//\[domain\]/$DOMAIN}
      if [ $FIRST_DOMAIN -eq 1 ] || [ "$OUTPUT" != "$BASE_OUTPUT" ]; then
        rm -f $OUTPUT &>/dev/null
        if [ -f $OUTPUT ]; then
          >&2 echo "Output file --output=$OUTPUT already exists and cannot be removed"
          exit 1
        fi
        touch $OUTPUT &>/dev/null
        if ! [ -f $OUTPUT ]; then
          >&2 echo "Unable to create output file --output=$OUTPUT"
          exit 1
        fi
      fi
    fi
    FIRST_DOMAIN=0

    # Zone file header - skipped for CSV
    if [ $CSV -eq 1 ] && [ $CSV_NO_HEADER -eq 0 ]; then
      cols='Name,TTL,Record Type,Record Data'
      if [ $CSV_ADD_DOMAIN -eq 1 ]; then
        cols="Domain,$cols"
      fi
      # CSV header row
      if [ $FIRST_DOMAIN -eq 1 ] || [ "$OUTPUT" != "$BASE_OUTPUT" ]; then
        if [ $OUTPUT = "stdout" ]; then
          echo $cols
        else
          echo $cols >>$OUTPUT
        fi
      fi
    elif [ $CSV -eq 0 ]; then
      print_to_output "\$ORIGIN $DOMAIN." 1
      if [[ $SOA =~ ([0-9]+)[[:blank:]]+[INin]{2}[[:blank:]] ]]; then
        print_to_output "\$TTL ${BASH_REMATCH[1]}" 1
      else
        print_to_output "\$TTL $DEFAULT_TTL" 1
      fi
    fi

    # Non brute-force records
    has_a=0
    has_aaaa=0
    for type in ${rr_types[@]}; do
      type_lower=$(echo "$type" | awk '{print tolower($0)}')
      if [ $type_lower = "a" ]; then
        has_a=1
      elif [ $type_lower = "aaaa" ]; then
        has_aaaa=1
      fi
      if ! [ -z "$SOA" ] && [ $type_lower = "soa" ]; then
        print_to_output "$SOA"
      else
        response=$(dig_cmd $DOMAIN $type) && if [ "$response" != "" ]; then print_to_output "$response"; fi &
        ns_ptr=$(( $ns_ptr + 1 ))
        subprocs=$(($subprocs + 1))
      fi
    done
  
    # Determine if wildcard records exist
    if [ $dictionary_limit -gt 0 ] && [ $NO_WILDCARD_CHECK -eq 0 ]; then
      for type in A AAAA; do
        ip=
        if [ $type = "AAAA" ] && [ $has_aaaa -eq 1 ]; then
          ip=$(dig_cmd braxfr${RANDOM}.${DOMAIN} AAAA 1)
          ns_ptr=$(( $ns_ptr + 1 ))
        elif [ $type = "A" ] && [ $has_a -eq 1 ]; then 
          ip=$(dig_cmd braxfr${RANDOM}.${DOMAIN} A 1)
          ns_ptr=$(( $ns_ptr + 1 ))
        fi
      
        if [ "$ip" != "" ]; then
          if [ $type = "AAAA" ]; then
            print_verbose "Discovered wildcard AAAA $ip"
            wildcard_aaaa=$ip
          else
            print_verbose "Discovered wildcard A $ip"
            wildcard_a=$ip
          fi
          response=$(dig_cmd braxfr${RANDOM}.${DOMAIN} $type) && if [ "$response" != "" ]; then print_to_output "$response" 0 1; fi &
          ns_ptr=$(( $ns_ptr + 1 ))
        fi
      done
      wait
    fi

    # Brute force records
    words=0
    while read host; do
      words=$(( $words + 1 ))
      if [ $words -ge $dictionary_limit ]; then
        print_verbose "DICTIONARY_LIMIT $dictionary_limit reached - skipping remaining dictionary words"
        break
      fi
      for type in ${rr_br_types[@]}; do
        response=$(dig_cmd $host.$DOMAIN $type) && if [ "$response" != "" ]; then print_to_output "$response"; fi &
        ns_ptr=$(( $ns_ptr + 1 ))
        # wait if sub processes >= CONCURRENCY or connections per name server will be 
        # > MAX_NS_CONS on the next iteration
        subprocs=$(($subprocs + 1))
        cons_per_ns=$(( $subprocs/$ns_count + 1 ))
        if [ $subprocs -ge $concurrency ] || [ $cons_per_ns -gt $max_ns_cons ]; then
          if [ $VERBOSE -eq 1 ]; then print_verbose "WAIT> concurrency=$concurrency; subprocs=$subprocs; MAX_NS_CONS=$max_ns_cons; ns_count=$ns_count; connections per ns=$cons_per_ns"; fi
          subprocs=0
          wait
        fi
      done
    done <$dictionary
  done <$DOMAIN
  
done
wait
rm -f $domain_file

# Remove temporary dictionary file
if [ "${dictionary:0:10}" = '/tmp/braxfr_' ]; then
  rm -f $dictionary
fi
